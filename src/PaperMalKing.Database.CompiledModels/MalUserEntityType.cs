// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using PaperMalKing.Database.Models;
using PaperMalKing.Database.Models.MyAnimeList;

#pragma warning disable 219, 612, 618
#nullable disable

namespace PaperMalKing.Database.CompiledModels
{
    [EntityFrameworkInternal]
    public partial class MalUserEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "PaperMalKing.Database.Models.MyAnimeList.MalUser",
                typeof(MalUser),
                baseEntityType,
                propertyCount: 9,
                navigationCount: 7,
                foreignKeyCount: 1,
                unnamedIndexCount: 2,
                keyCount: 1);

            var userId = runtimeEntityType.AddProperty(
                "UserId",
                typeof(uint),
                propertyInfo: typeof(MalUser).GetProperty("UserId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(MalUser).GetField("<UserId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0u);
            userId.SetGetter(
                uint (MalUser entity) => MalUserUnsafeAccessors.UserId(entity),
                bool (MalUser entity) => MalUserUnsafeAccessors.UserId(entity) == 0U,
                uint (MalUser instance) => MalUserUnsafeAccessors.UserId(instance),
                bool (MalUser instance) => MalUserUnsafeAccessors.UserId(instance) == 0U);
            userId.SetSetter(
                (MalUser entity, uint value) => MalUserUnsafeAccessors.UserId(entity) = value);
            userId.SetMaterializationSetter(
                (MalUser entity, uint value) => MalUserUnsafeAccessors.UserId(entity) = value);
            userId.SetAccessors(
                uint (InternalEntityEntry entry) => MalUserUnsafeAccessors.UserId(((MalUser)(entry.Entity))),
                uint (InternalEntityEntry entry) => MalUserUnsafeAccessors.UserId(((MalUser)(entry.Entity))),
                uint (InternalEntityEntry entry) => entry.ReadOriginalValue<uint>(userId, 0),
                uint (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<uint>(userId, 0),
                object (ValueBuffer valueBuffer) => valueBuffer[0]);
            userId.SetPropertyIndexes(
                index: 0,
                originalValueIndex: 0,
                shadowIndex: -1,
                relationshipIndex: 0,
                storeGenerationIndex: -1);
            userId.TypeMapping = UIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                providerValueComparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            userId.SetCurrentValueComparer(new EntryCurrentValueComparer<uint>(userId));

            var discordUserId = runtimeEntityType.AddProperty(
                "DiscordUserId",
                typeof(ulong),
                propertyInfo: typeof(MalUser).GetProperty("DiscordUserId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(MalUser).GetField("<DiscordUserId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0ul);
            discordUserId.SetGetter(
                ulong (MalUser entity) => MalUserUnsafeAccessors.DiscordUserId(entity),
                bool (MalUser entity) => MalUserUnsafeAccessors.DiscordUserId(entity) == 0UL,
                ulong (MalUser instance) => MalUserUnsafeAccessors.DiscordUserId(instance),
                bool (MalUser instance) => MalUserUnsafeAccessors.DiscordUserId(instance) == 0UL);
            discordUserId.SetSetter(
                (MalUser entity, ulong value) => MalUserUnsafeAccessors.DiscordUserId(entity) = value);
            discordUserId.SetMaterializationSetter(
                (MalUser entity, ulong value) => MalUserUnsafeAccessors.DiscordUserId(entity) = value);
            discordUserId.SetAccessors(
                ulong (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<ulong>(0) : (entry.FlaggedAsTemporary(1) && MalUserUnsafeAccessors.DiscordUserId(((MalUser)(entry.Entity))) == 0UL ? entry.ReadTemporaryValue<ulong>(0) : MalUserUnsafeAccessors.DiscordUserId(((MalUser)(entry.Entity))))),
                ulong (InternalEntityEntry entry) => MalUserUnsafeAccessors.DiscordUserId(((MalUser)(entry.Entity))),
                ulong (InternalEntityEntry entry) => entry.ReadOriginalValue<ulong>(discordUserId, 1),
                ulong (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<ulong>(discordUserId, 1),
                object (ValueBuffer valueBuffer) => valueBuffer[1]);
            discordUserId.SetPropertyIndexes(
                index: 1,
                originalValueIndex: 1,
                shadowIndex: -1,
                relationshipIndex: 1,
                storeGenerationIndex: 0);
            discordUserId.TypeMapping = SqliteULongTypeMapping.Default;
            discordUserId.SetCurrentValueComparer(new EntryCurrentValueComparer<ulong>(discordUserId));

            var favoritesIdHash = runtimeEntityType.AddProperty(
                "FavoritesIdHash",
                typeof(string),
                propertyInfo: typeof(MalUser).GetProperty("FavoritesIdHash", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(MalUser).GetField("<FavoritesIdHash>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd);
            favoritesIdHash.SetGetter(
                string (MalUser entity) => MalUserUnsafeAccessors.FavoritesIdHash(entity),
                bool (MalUser entity) => MalUserUnsafeAccessors.FavoritesIdHash(entity) == null,
                string (MalUser instance) => MalUserUnsafeAccessors.FavoritesIdHash(instance),
                bool (MalUser instance) => MalUserUnsafeAccessors.FavoritesIdHash(instance) == null);
            favoritesIdHash.SetSetter(
                (MalUser entity, string value) => MalUserUnsafeAccessors.FavoritesIdHash(entity) = value);
            favoritesIdHash.SetMaterializationSetter(
                (MalUser entity, string value) => MalUserUnsafeAccessors.FavoritesIdHash(entity) = value);
            favoritesIdHash.SetAccessors(
                string (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(2) ? entry.ReadStoreGeneratedValue<string>(1) : (entry.FlaggedAsTemporary(2) && MalUserUnsafeAccessors.FavoritesIdHash(((MalUser)(entry.Entity))) == null ? entry.ReadTemporaryValue<string>(1) : MalUserUnsafeAccessors.FavoritesIdHash(((MalUser)(entry.Entity))))),
                string (InternalEntityEntry entry) => MalUserUnsafeAccessors.FavoritesIdHash(((MalUser)(entry.Entity))),
                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(favoritesIdHash, 2),
                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(favoritesIdHash),
                object (ValueBuffer valueBuffer) => valueBuffer[2]);
            favoritesIdHash.SetPropertyIndexes(
                index: 2,
                originalValueIndex: 2,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: 1);
            favoritesIdHash.TypeMapping = SqliteStringTypeMapping.Default;
            favoritesIdHash.AddAnnotation("Relational:DefaultValue", "");

            var features = runtimeEntityType.AddProperty(
                "Features",
                typeof(MalUserFeatures),
                propertyInfo: typeof(MalUser).GetProperty("Features", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(MalUser).GetField("<Features>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd);
            features.SetGetter(
                MalUserFeatures (MalUser entity) => MalUserUnsafeAccessors.Features(entity),
                bool (MalUser entity) => object.Equals(((object)(MalUserUnsafeAccessors.Features(entity))), ((object)(MalUserFeatures.None))),
                MalUserFeatures (MalUser instance) => MalUserUnsafeAccessors.Features(instance),
                bool (MalUser instance) => object.Equals(((object)(MalUserUnsafeAccessors.Features(instance))), ((object)(MalUserFeatures.None))));
            features.SetSetter(
                (MalUser entity, MalUserFeatures value) => MalUserUnsafeAccessors.Features(entity) = value);
            features.SetMaterializationSetter(
                (MalUser entity, MalUserFeatures value) => MalUserUnsafeAccessors.Features(entity) = value);
            features.SetAccessors(
                MalUserFeatures (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(3) ? entry.ReadStoreGeneratedValue<MalUserFeatures>(2) : (entry.FlaggedAsTemporary(3) && object.Equals(((object)(MalUserUnsafeAccessors.Features(((MalUser)(entry.Entity))))), ((object)(MalUserFeatures.None))) ? entry.ReadTemporaryValue<MalUserFeatures>(2) : MalUserUnsafeAccessors.Features(((MalUser)(entry.Entity))))),
                MalUserFeatures (InternalEntityEntry entry) => MalUserUnsafeAccessors.Features(((MalUser)(entry.Entity))),
                MalUserFeatures (InternalEntityEntry entry) => entry.ReadOriginalValue<MalUserFeatures>(features, 3),
                MalUserFeatures (InternalEntityEntry entry) => entry.GetCurrentValue<MalUserFeatures>(features),
                object (ValueBuffer valueBuffer) => valueBuffer[3]);
            features.SetPropertyIndexes(
                index: 3,
                originalValueIndex: 3,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: 2);
            features.TypeMapping = SqliteULongTypeMapping.Default.Clone(
                comparer: new ValueComparer<MalUserFeatures>(
                    bool (MalUserFeatures v1, MalUserFeatures v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (MalUserFeatures v) => ((object)v).GetHashCode(),
                    MalUserFeatures (MalUserFeatures v) => v),
                keyComparer: new ValueComparer<MalUserFeatures>(
                    bool (MalUserFeatures v1, MalUserFeatures v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (MalUserFeatures v) => ((object)v).GetHashCode(),
                    MalUserFeatures (MalUserFeatures v) => v),
                providerValueComparer: new ValueComparer<ulong>(
                    bool (ulong v1, ulong v2) => v1 == v2,
                    int (ulong v) => ((object)v).GetHashCode(),
                    ulong (ulong v) => v),
                converter: new ValueConverter<MalUserFeatures, ulong>(
                    ulong (MalUserFeatures value) => ((ulong)(value)),
                    MalUserFeatures (ulong value) => ((MalUserFeatures)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<MalUserFeatures, ulong>(
                    JsonUInt64ReaderWriter.Instance,
                    new ValueConverter<MalUserFeatures, ulong>(
                        ulong (MalUserFeatures value) => ((ulong)(value)),
                        MalUserFeatures (ulong value) => ((MalUserFeatures)(value)))));
            features.SetSentinelFromProviderValue(0ul);
            features.AddAnnotation("Relational:DefaultValue", MalUserFeatures.AnimeList | MalUserFeatures.MangaList | MalUserFeatures.Favorites | MalUserFeatures.Mention | MalUserFeatures.Website | MalUserFeatures.MediaFormat | MalUserFeatures.MediaStatus);

            var lastAnimeUpdateHash = runtimeEntityType.AddProperty(
                "LastAnimeUpdateHash",
                typeof(string),
                propertyInfo: typeof(MalUser).GetProperty("LastAnimeUpdateHash", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(MalUser).GetField("<LastAnimeUpdateHash>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            lastAnimeUpdateHash.SetGetter(
                string (MalUser entity) => MalUserUnsafeAccessors.LastAnimeUpdateHash(entity),
                bool (MalUser entity) => MalUserUnsafeAccessors.LastAnimeUpdateHash(entity) == null,
                string (MalUser instance) => MalUserUnsafeAccessors.LastAnimeUpdateHash(instance),
                bool (MalUser instance) => MalUserUnsafeAccessors.LastAnimeUpdateHash(instance) == null);
            lastAnimeUpdateHash.SetSetter(
                (MalUser entity, string value) => MalUserUnsafeAccessors.LastAnimeUpdateHash(entity) = value);
            lastAnimeUpdateHash.SetMaterializationSetter(
                (MalUser entity, string value) => MalUserUnsafeAccessors.LastAnimeUpdateHash(entity) = value);
            lastAnimeUpdateHash.SetAccessors(
                string (InternalEntityEntry entry) => MalUserUnsafeAccessors.LastAnimeUpdateHash(((MalUser)(entry.Entity))),
                string (InternalEntityEntry entry) => MalUserUnsafeAccessors.LastAnimeUpdateHash(((MalUser)(entry.Entity))),
                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(lastAnimeUpdateHash, 4),
                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(lastAnimeUpdateHash),
                object (ValueBuffer valueBuffer) => valueBuffer[4]);
            lastAnimeUpdateHash.SetPropertyIndexes(
                index: 4,
                originalValueIndex: 4,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            lastAnimeUpdateHash.TypeMapping = SqliteStringTypeMapping.Default;

            var lastMangaUpdateHash = runtimeEntityType.AddProperty(
                "LastMangaUpdateHash",
                typeof(string),
                propertyInfo: typeof(MalUser).GetProperty("LastMangaUpdateHash", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(MalUser).GetField("<LastMangaUpdateHash>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            lastMangaUpdateHash.SetGetter(
                string (MalUser entity) => MalUserUnsafeAccessors.LastMangaUpdateHash(entity),
                bool (MalUser entity) => MalUserUnsafeAccessors.LastMangaUpdateHash(entity) == null,
                string (MalUser instance) => MalUserUnsafeAccessors.LastMangaUpdateHash(instance),
                bool (MalUser instance) => MalUserUnsafeAccessors.LastMangaUpdateHash(instance) == null);
            lastMangaUpdateHash.SetSetter(
                (MalUser entity, string value) => MalUserUnsafeAccessors.LastMangaUpdateHash(entity) = value);
            lastMangaUpdateHash.SetMaterializationSetter(
                (MalUser entity, string value) => MalUserUnsafeAccessors.LastMangaUpdateHash(entity) = value);
            lastMangaUpdateHash.SetAccessors(
                string (InternalEntityEntry entry) => MalUserUnsafeAccessors.LastMangaUpdateHash(((MalUser)(entry.Entity))),
                string (InternalEntityEntry entry) => MalUserUnsafeAccessors.LastMangaUpdateHash(((MalUser)(entry.Entity))),
                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(lastMangaUpdateHash, 5),
                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(lastMangaUpdateHash),
                object (ValueBuffer valueBuffer) => valueBuffer[5]);
            lastMangaUpdateHash.SetPropertyIndexes(
                index: 5,
                originalValueIndex: 5,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            lastMangaUpdateHash.TypeMapping = SqliteStringTypeMapping.Default;

            var lastUpdatedAnimeListTimestamp = runtimeEntityType.AddProperty(
                "LastUpdatedAnimeListTimestamp",
                typeof(DateTimeOffset),
                propertyInfo: typeof(MalUser).GetProperty("LastUpdatedAnimeListTimestamp", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(MalUser).GetField("<LastUpdatedAnimeListTimestamp>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeOffsetToBinaryConverter());
            lastUpdatedAnimeListTimestamp.SetGetter(
                DateTimeOffset (MalUser entity) => MalUserUnsafeAccessors.LastUpdatedAnimeListTimestamp(entity),
                bool (MalUser entity) => MalUserUnsafeAccessors.LastUpdatedAnimeListTimestamp(entity).EqualsExact(default(DateTimeOffset)),
                DateTimeOffset (MalUser instance) => MalUserUnsafeAccessors.LastUpdatedAnimeListTimestamp(instance),
                bool (MalUser instance) => MalUserUnsafeAccessors.LastUpdatedAnimeListTimestamp(instance).EqualsExact(default(DateTimeOffset)));
            lastUpdatedAnimeListTimestamp.SetSetter(
                (MalUser entity, DateTimeOffset value) => MalUserUnsafeAccessors.LastUpdatedAnimeListTimestamp(entity) = value);
            lastUpdatedAnimeListTimestamp.SetMaterializationSetter(
                (MalUser entity, DateTimeOffset value) => MalUserUnsafeAccessors.LastUpdatedAnimeListTimestamp(entity) = value);
            lastUpdatedAnimeListTimestamp.SetAccessors(
                DateTimeOffset (InternalEntityEntry entry) => MalUserUnsafeAccessors.LastUpdatedAnimeListTimestamp(((MalUser)(entry.Entity))),
                DateTimeOffset (InternalEntityEntry entry) => MalUserUnsafeAccessors.LastUpdatedAnimeListTimestamp(((MalUser)(entry.Entity))),
                DateTimeOffset (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTimeOffset>(lastUpdatedAnimeListTimestamp, 6),
                DateTimeOffset (InternalEntityEntry entry) => entry.GetCurrentValue<DateTimeOffset>(lastUpdatedAnimeListTimestamp),
                object (ValueBuffer valueBuffer) => valueBuffer[6]);
            lastUpdatedAnimeListTimestamp.SetPropertyIndexes(
                index: 6,
                originalValueIndex: 6,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            lastUpdatedAnimeListTimestamp.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                keyComparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<DateTimeOffset, long>(
                    long (DateTimeOffset v) => DateTimeOffsetToBinaryConverter.ToLong(v),
                    DateTimeOffset (long v) => DateTimeOffsetToBinaryConverter.ToDateTimeOffset(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTimeOffset, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<DateTimeOffset, long>(
                        long (DateTimeOffset v) => DateTimeOffsetToBinaryConverter.ToLong(v),
                        DateTimeOffset (long v) => DateTimeOffsetToBinaryConverter.ToDateTimeOffset(v))));
            lastUpdatedAnimeListTimestamp.SetSentinelFromProviderValue(0L);

            var lastUpdatedMangaListTimestamp = runtimeEntityType.AddProperty(
                "LastUpdatedMangaListTimestamp",
                typeof(DateTimeOffset),
                propertyInfo: typeof(MalUser).GetProperty("LastUpdatedMangaListTimestamp", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(MalUser).GetField("<LastUpdatedMangaListTimestamp>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeOffsetToBinaryConverter());
            lastUpdatedMangaListTimestamp.SetGetter(
                DateTimeOffset (MalUser entity) => MalUserUnsafeAccessors.LastUpdatedMangaListTimestamp(entity),
                bool (MalUser entity) => MalUserUnsafeAccessors.LastUpdatedMangaListTimestamp(entity).EqualsExact(default(DateTimeOffset)),
                DateTimeOffset (MalUser instance) => MalUserUnsafeAccessors.LastUpdatedMangaListTimestamp(instance),
                bool (MalUser instance) => MalUserUnsafeAccessors.LastUpdatedMangaListTimestamp(instance).EqualsExact(default(DateTimeOffset)));
            lastUpdatedMangaListTimestamp.SetSetter(
                (MalUser entity, DateTimeOffset value) => MalUserUnsafeAccessors.LastUpdatedMangaListTimestamp(entity) = value);
            lastUpdatedMangaListTimestamp.SetMaterializationSetter(
                (MalUser entity, DateTimeOffset value) => MalUserUnsafeAccessors.LastUpdatedMangaListTimestamp(entity) = value);
            lastUpdatedMangaListTimestamp.SetAccessors(
                DateTimeOffset (InternalEntityEntry entry) => MalUserUnsafeAccessors.LastUpdatedMangaListTimestamp(((MalUser)(entry.Entity))),
                DateTimeOffset (InternalEntityEntry entry) => MalUserUnsafeAccessors.LastUpdatedMangaListTimestamp(((MalUser)(entry.Entity))),
                DateTimeOffset (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTimeOffset>(lastUpdatedMangaListTimestamp, 7),
                DateTimeOffset (InternalEntityEntry entry) => entry.GetCurrentValue<DateTimeOffset>(lastUpdatedMangaListTimestamp),
                object (ValueBuffer valueBuffer) => valueBuffer[7]);
            lastUpdatedMangaListTimestamp.SetPropertyIndexes(
                index: 7,
                originalValueIndex: 7,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            lastUpdatedMangaListTimestamp.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                keyComparer: new ValueComparer<DateTimeOffset>(
                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
                    DateTimeOffset (DateTimeOffset v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<DateTimeOffset, long>(
                    long (DateTimeOffset v) => DateTimeOffsetToBinaryConverter.ToLong(v),
                    DateTimeOffset (long v) => DateTimeOffsetToBinaryConverter.ToDateTimeOffset(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTimeOffset, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<DateTimeOffset, long>(
                        long (DateTimeOffset v) => DateTimeOffsetToBinaryConverter.ToLong(v),
                        DateTimeOffset (long v) => DateTimeOffsetToBinaryConverter.ToDateTimeOffset(v))));
            lastUpdatedMangaListTimestamp.SetSentinelFromProviderValue(0L);

            var username = runtimeEntityType.AddProperty(
                "Username",
                typeof(string),
                propertyInfo: typeof(MalUser).GetProperty("Username", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(MalUser).GetField("<Username>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            username.SetGetter(
                string (MalUser entity) => MalUserUnsafeAccessors.Username(entity),
                bool (MalUser entity) => MalUserUnsafeAccessors.Username(entity) == null,
                string (MalUser instance) => MalUserUnsafeAccessors.Username(instance),
                bool (MalUser instance) => MalUserUnsafeAccessors.Username(instance) == null);
            username.SetSetter(
                (MalUser entity, string value) => MalUserUnsafeAccessors.Username(entity) = value);
            username.SetMaterializationSetter(
                (MalUser entity, string value) => MalUserUnsafeAccessors.Username(entity) = value);
            username.SetAccessors(
                string (InternalEntityEntry entry) => MalUserUnsafeAccessors.Username(((MalUser)(entry.Entity))),
                string (InternalEntityEntry entry) => MalUserUnsafeAccessors.Username(((MalUser)(entry.Entity))),
                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(username, 8),
                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(username),
                object (ValueBuffer valueBuffer) => valueBuffer[8]);
            username.SetPropertyIndexes(
                index: 8,
                originalValueIndex: 8,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            username.TypeMapping = SqliteStringTypeMapping.Default;

            var key = runtimeEntityType.AddKey(
                new[] { userId });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { discordUserId },
                unique: true);

            var index0 = runtimeEntityType.AddIndex(
                new[] { features });

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("DiscordUserId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("DiscordUserId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true);

            var discordUser = declaringEntityType.AddNavigation("DiscordUser",
                runtimeForeignKey,
                onDependent: true,
                typeof(DiscordUser),
                propertyInfo: typeof(MalUser).GetProperty("DiscordUser", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(MalUser).GetField("<DiscordUser>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            discordUser.SetGetter(
                DiscordUser (MalUser entity) => MalUserUnsafeAccessors.DiscordUser(entity),
                bool (MalUser entity) => MalUserUnsafeAccessors.DiscordUser(entity) == null,
                DiscordUser (MalUser instance) => MalUserUnsafeAccessors.DiscordUser(instance),
                bool (MalUser instance) => MalUserUnsafeAccessors.DiscordUser(instance) == null);
            discordUser.SetSetter(
                (MalUser entity, DiscordUser value) => MalUserUnsafeAccessors.DiscordUser(entity) = value);
            discordUser.SetMaterializationSetter(
                (MalUser entity, DiscordUser value) => MalUserUnsafeAccessors.DiscordUser(entity) = value);
            discordUser.SetAccessors(
                DiscordUser (InternalEntityEntry entry) => MalUserUnsafeAccessors.DiscordUser(((MalUser)(entry.Entity))),
                DiscordUser (InternalEntityEntry entry) => MalUserUnsafeAccessors.DiscordUser(((MalUser)(entry.Entity))),
                null,
                DiscordUser (InternalEntityEntry entry) => entry.GetCurrentValue<DiscordUser>(discordUser),
                null);
            discordUser.SetPropertyIndexes(
                index: 1,
                originalValueIndex: -1,
                shadowIndex: -1,
                relationshipIndex: 3,
                storeGenerationIndex: -1);
            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var userId = runtimeEntityType.FindProperty("UserId");
            var discordUserId = runtimeEntityType.FindProperty("DiscordUserId");
            var favoritesIdHash = runtimeEntityType.FindProperty("FavoritesIdHash");
            var features = runtimeEntityType.FindProperty("Features");
            var lastAnimeUpdateHash = runtimeEntityType.FindProperty("LastAnimeUpdateHash");
            var lastMangaUpdateHash = runtimeEntityType.FindProperty("LastMangaUpdateHash");
            var lastUpdatedAnimeListTimestamp = runtimeEntityType.FindProperty("LastUpdatedAnimeListTimestamp");
            var lastUpdatedMangaListTimestamp = runtimeEntityType.FindProperty("LastUpdatedMangaListTimestamp");
            var username = runtimeEntityType.FindProperty("Username");
            var key = runtimeEntityType.FindKey(new[] { userId });
            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<uint>(key));
            key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<uint>(key));
            var colors = runtimeEntityType.FindNavigation("Colors");
            var discordUser = runtimeEntityType.FindNavigation("DiscordUser");
            var favoriteAnimes = runtimeEntityType.FindNavigation("FavoriteAnimes");
            var favoriteCharacters = runtimeEntityType.FindNavigation("FavoriteCharacters");
            var favoriteCompanies = runtimeEntityType.FindNavigation("FavoriteCompanies");
            var favoriteMangas = runtimeEntityType.FindNavigation("FavoriteMangas");
            var favoritePeople = runtimeEntityType.FindNavigation("FavoritePeople");
            runtimeEntityType.SetOriginalValuesFactory(
                ISnapshot (InternalEntityEntry source) =>
                {
                    var entity = ((MalUser)(source.Entity));
                    return ((ISnapshot)(new Snapshot<uint, ulong, string, MalUserFeatures, string, string, DateTimeOffset, DateTimeOffset, string>(((ValueComparer<uint>)(((IProperty)userId).GetValueComparer())).Snapshot(source.GetCurrentValue<uint>(userId)), ((ValueComparer<ulong>)(((IProperty)discordUserId).GetValueComparer())).Snapshot(source.GetCurrentValue<ulong>(discordUserId)), (source.GetCurrentValue<string>(favoritesIdHash) == null ? null : ((ValueComparer<string>)(((IProperty)favoritesIdHash).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(favoritesIdHash))), ((ValueComparer<MalUserFeatures>)(((IProperty)features).GetValueComparer())).Snapshot(source.GetCurrentValue<MalUserFeatures>(features)), (source.GetCurrentValue<string>(lastAnimeUpdateHash) == null ? null : ((ValueComparer<string>)(((IProperty)lastAnimeUpdateHash).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(lastAnimeUpdateHash))), (source.GetCurrentValue<string>(lastMangaUpdateHash) == null ? null : ((ValueComparer<string>)(((IProperty)lastMangaUpdateHash).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(lastMangaUpdateHash))), ((ValueComparer<DateTimeOffset>)(((IProperty)lastUpdatedAnimeListTimestamp).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTimeOffset>(lastUpdatedAnimeListTimestamp)), ((ValueComparer<DateTimeOffset>)(((IProperty)lastUpdatedMangaListTimestamp).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTimeOffset>(lastUpdatedMangaListTimestamp)), (source.GetCurrentValue<string>(username) == null ? null : ((ValueComparer<string>)(((IProperty)username).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(username))))));
                });
            runtimeEntityType.SetStoreGeneratedValuesFactory(
                ISnapshot () => ((ISnapshot)(new Snapshot<ulong, string, MalUserFeatures>(((ValueComparer<ulong>)(((IProperty)discordUserId).GetValueComparer())).Snapshot(default(ulong)), (default(string) == null ? null : ((ValueComparer<string>)(((IProperty)favoritesIdHash).GetValueComparer())).Snapshot(default(string))), ((ValueComparer<MalUserFeatures>)(((IProperty)features).GetValueComparer())).Snapshot(default(MalUserFeatures))))));
            runtimeEntityType.SetTemporaryValuesFactory(
                ISnapshot (InternalEntityEntry source) => ((ISnapshot)(new Snapshot<ulong, string, MalUserFeatures>(default(ulong), default(string), default(MalUserFeatures)))));
            runtimeEntityType.SetShadowValuesFactory(
                ISnapshot (IDictionary<string, object> source) => Snapshot.Empty);
            runtimeEntityType.SetEmptyShadowValuesFactory(
                ISnapshot () => Snapshot.Empty);
            runtimeEntityType.SetRelationshipSnapshotFactory(
                ISnapshot (InternalEntityEntry source) =>
                {
                    var entity = ((MalUser)(source.Entity));
                    return ((ISnapshot)(new Snapshot<uint, ulong, object, object, object, object, object, object, object>(((ValueComparer<uint>)(((IProperty)userId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<uint>(userId)), ((ValueComparer<ulong>)(((IProperty)discordUserId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<ulong>(discordUserId)), SnapshotFactoryFactory.SnapshotCollection(MalUserUnsafeAccessors.Colors(entity)), MalUserUnsafeAccessors.DiscordUser(entity), SnapshotFactoryFactory.SnapshotCollection(MalUserUnsafeAccessors.FavoriteAnimes(entity)), SnapshotFactoryFactory.SnapshotCollection(MalUserUnsafeAccessors.FavoriteCharacters(entity)), SnapshotFactoryFactory.SnapshotCollection(MalUserUnsafeAccessors.FavoriteCompanies(entity)), SnapshotFactoryFactory.SnapshotCollection(MalUserUnsafeAccessors.FavoriteMangas(entity)), SnapshotFactoryFactory.SnapshotCollection(MalUserUnsafeAccessors.FavoritePeople(entity)))));
                });
            runtimeEntityType.Counts = new PropertyCounts(
                propertyCount: 9,
                navigationCount: 7,
                complexPropertyCount: 0,
                originalValueCount: 9,
                shadowCount: 0,
                relationshipCount: 9,
                storeGeneratedCount: 3);
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "MalUsers");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
